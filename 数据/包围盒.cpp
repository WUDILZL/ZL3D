#include "包围盒.h"

包围盒::包围盒()
{
}

包围盒::包围盒(std::vector<向量三维> _顶点集合)
{
	float MinX = FLT_MAX;
	float MinY = FLT_MAX;
	float MinZ = FLT_MAX;

	float MaxX = FLT_MIN;
	float MaxY = FLT_MIN;
	float MaxZ = FLT_MIN;

	for (int i = 0; i < _顶点集合.size(); i++)
	{
		向量三维 顶点 = _顶点集合[i];
		if (顶点.X < MinX) MinX = 顶点.X;
		if (顶点.X > MaxX) MaxX = 顶点.X;

		if (顶点.Y < MinY) MinY = 顶点.Y;
		if (顶点.Y > MaxY) MaxY = 顶点.Y;

		if (顶点.Z < MinZ) MinZ = 顶点.Z;
		if (顶点.Z > MaxZ) MaxZ = 顶点.Z;
	}

	最小值 =  向量三维(MinX, MinY, MinZ);
	最大值 =  向量三维(MaxX, MaxY, MaxZ);

	尺寸 = 最大值 - 最小值;
	中点 = 最小值 + (尺寸 * 0.5f);
}

包围盒::包围盒(向量三维 _最大值, 向量三维 _最小值)
{
	最小值 = 最小值;
	最大值 = 最大值;

	尺寸 = 最大值 - 最小值;
	中点 = 最小值 + (尺寸 * 0.5f);
}

包围盒::~包围盒()
{
}

std::vector<向量三维> 包围盒::获取顶点()
{
	std::vector<向量三维> 八个顶点(8);
	八个顶点[0] =  向量三维(最小值.X, 最大值.Y, 最大值.Z); //左上前
	八个顶点[1] =  向量三维(最大值.X, 最大值.Y, 最大值.Z); //右上前
	八个顶点[2] =  向量三维(最大值.X, 最小值.Y, 最大值.Z); //右下前
	八个顶点[3] =  向量三维(最小值.X, 最小值.Y, 最大值.Z); //左下前

	八个顶点[4] =  向量三维(最小值.X, 最大值.Y, 最小值.Z); //左上后
	八个顶点[5] =  向量三维(最大值.X, 最大值.Y, 最小值.Z); //右上后
	八个顶点[6] =  向量三维(最大值.X, 最小值.Y, 最小值.Z); //右下后
	八个顶点[7] =  向量三维(最小值.X, 最小值.Y, 最小值.Z); //左下后
	return 八个顶点;
}


std::vector<包围盒> 包围盒::拆分包围盒(包围盒 _包围盒)
{
	std::vector<包围盒> 新包围盒集(8);


	向量三维 最小值 = _包围盒.最小值;
	向量三维 最大值 = _包围盒.最大值;
	向量三维 中点 = _包围盒.中点;

	新包围盒集[0] =  包围盒(最小值, 中点);
	新包围盒集[1] =  包围盒( 向量三维(中点.X, 最小值.Y, 最小值.Z),  向量三维(最大值.X, 中点.Y, 中点.Z));
	新包围盒集[2] =  包围盒( 向量三维(最小值.X, 中点.Y, 最小值.Z),  向量三维(中点.X, 最大值.Y, 中点.Z));
	新包围盒集[3] =  包围盒( 向量三维(中点.X, 中点.Y, 最小值.Z),  向量三维(最大值.X, 最大值.Y, 中点.Z));
	新包围盒集[4] =  包围盒( 向量三维(最小值.X, 最小值.Y, 中点.Z),  向量三维(中点.X, 中点.Y, 最大值.Z));
	新包围盒集[5] =  包围盒( 向量三维(中点.X, 最小值.Y, 中点.Z),  向量三维(最大值.X, 中点.Y, 最大值.Z));
	新包围盒集[6] =  包围盒( 向量三维(最小值.X, 中点.Y, 中点.Z),  向量三维(中点.X, 最大值.Y, 最大值.Z));
	新包围盒集[7] =  包围盒(中点, 最大值);

	return 新包围盒集;
}

包围盒 包围盒::修改包围盒(包围盒 _包围盒, 向量三维 修改值)
{
	return 包围盒(_包围盒.最小值 - 修改值, _包围盒.最大值 + 修改值);
}

bool 包围盒::判断点在包围盒中(包围盒 _包围盒, 向量三维 顶点)
{
	if (顶点.X >= _包围盒.最小值.X && 顶点.X <= _包围盒.最大值.X &&
		顶点.Y >= _包围盒.最小值.Y && 顶点.Y <= _包围盒.最大值.Y &&
		顶点.Z >= _包围盒.最小值.Z && 顶点.Z <= _包围盒.最大值.Z
		)
	{
		return true;
	}
	return false;
}

bool 包围盒::判断点集合包围盒中(包围盒 _包围盒, std::vector<向量三维> 顶点集合)
{
	for (int i = 0; i < 顶点集合.size(); i++)
	{
		向量三维 顶点 = 顶点集合[i];
		if (!判断点在包围盒中(_包围盒, 顶点))return true;
	}
	return false;
}

包围盒 包围盒::operator+(向量三维 向量)
{
	return 包围盒(this->最小值 + 向量, this->最大值 + 向量);
}

包围盒 包围盒::operator*(向量三维 向量)
{
	return 包围盒(this->最小值 * 向量, this->最大值 * 向量);
}

包围盒 包围盒::operator*(矩阵4X4 向量)
{
	return 包围盒(向量* this->最小值, 向量* this->最大值 );
}
