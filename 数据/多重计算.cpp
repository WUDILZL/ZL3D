#include "多重计算.h"

向量二维 计算三角UV插值(向量三维 三角权重, 向量二维 uv1, 向量二维 uv2, 向量二维 uv3)
{
	向量二维 mm = uv1 * 三角权重.X;
	向量二维 interpolatedUV = mm;
	mm = uv2 * 三角权重.Y;
	interpolatedUV = mm + interpolatedUV;
	mm = uv3 * 三角权重.Z;
	return interpolatedUV + mm;
}

向量三维 计算向量旋转(向量三维 操作向量, 向量三维 旋转中心, 四元数 旋转)
{
	向量三维 向量差 = 操作向量 - 旋转中心;
	向量三维 相对坐标 = 四元数::四元数乘三维向量(向量差, 旋转);
	return 相对坐标 + 旋转中心;
}

向量三维 弧度转角度(向量三维 弧度)
{
    return 向量三维(计算::弧度转角度(弧度.X), 计算::弧度转角度(弧度.Y), 计算::弧度转角度(弧度.Z));
}

bool 分解变换矩阵(矩阵4X4 矩阵, 向量三维& 缩放, 四元数& 旋转, 向量三维& 平移)
{
    平移.X = 矩阵.M41;
    平移.Y = 矩阵.M42;
    平移.Z = 矩阵.M43;
    缩放.X = std::sqrt(矩阵.M11 * 矩阵.M11 + 矩阵.M12 * 矩阵.M12 + 矩阵.M13 * 矩阵.M13);
    缩放.Y = std::sqrt(矩阵.M21 * 矩阵.M21 + 矩阵.M22 * 矩阵.M22 + 矩阵.M23 * 矩阵.M23);
    缩放.Z = std::sqrt(矩阵.M31 * 矩阵.M31 + 矩阵.M32 * 矩阵.M32 + 矩阵.M33 * 矩阵.M33);
    if (计算::等于0(缩放.X) || 计算::等于0(缩放.Y) || 计算::等于0(缩放.Z))
    {
        旋转 = 四元数::单位四元数();
        return false;
    }

    矩阵4X4 旋转矩阵;
    旋转矩阵.M11 = 矩阵.M11 / 缩放.X;
    旋转矩阵.M12 = 矩阵.M12 / 缩放.X;
    旋转矩阵.M13 = 矩阵.M13 / 缩放.X;
    旋转矩阵.M21 = 矩阵.M21 / 缩放.Y;
    旋转矩阵.M22 = 矩阵.M22 / 缩放.Y;
    旋转矩阵.M23 = 矩阵.M23 / 缩放.Y;
    旋转矩阵.M31 = 矩阵.M31 / 缩放.Z;
    旋转矩阵.M32 = 矩阵.M32 / 缩放.Z;
    旋转矩阵.M33 = 矩阵.M33 / 缩放.Z;
    旋转矩阵.M44 = 1.0f;
    旋转 = 四元数::创建矩阵旋转(旋转矩阵);
    return true;
}

bool 分解等比例变换矩阵(矩阵4X4 矩阵, float& 缩放, 四元数& 旋转, 向量三维& 平移)
{
    平移.X = 矩阵.M41;
    平移.Y = 矩阵.M42;
    平移.Z = 矩阵.M43;
    缩放 = std::sqrt(矩阵.M11 * 矩阵.M11 + 矩阵.M12 * 矩阵.M12 + 矩阵.M13 * 矩阵.M13);
    float num = 1.0f / 缩放;
    if (std::abs(缩放) < 1E-06f)
    {
        旋转 = 四元数::单位四元数();
        return false;
    }

    矩阵4X4 matrix;
    matrix.M11 = 矩阵.M11 * num;
    matrix.M12 = 矩阵.M12 * num;
    matrix.M13 = 矩阵.M13 * num;
    matrix.M21 = 矩阵.M21 * num;
    matrix.M22 = 矩阵.M22 * num;
    matrix.M23 = 矩阵.M23 * num;
    matrix.M31 = 矩阵.M31 * num;
    matrix.M32 = 矩阵.M32 * num;
    matrix.M33 = 矩阵.M33 * num;
    matrix.M44 = 1.0f;
    旋转 = 四元数::创建矩阵旋转(matrix);
    return true;
}

//矩阵旋转
//向量V* 四元数Q = 向量V' 
//
//1. 计算旋转后的向量V'的X分量： 
//V'.X = V.X * (1 - 2 * (Qy^2 + Qz^2)) + V.Y * (2 * (Qx * Qy - Qz * Qw)) + V.Z * (2 * (Qx * Qz + Qy * Qw)) 
//
//2. 计算旋转后的向量V'的Y分量： 
//V'.Y = V.X * (2 * (Qx * Qy + Qz * Qw)) + V.Y * (1 - 2 * (Qx^2 + Qz^2)) + V.Z * (2 * (Qy * Qz - Qx * Qw)) 
//
//3. 计算旋转后的向量V'的Z分量： 
//V'.Z = V.X * (2 * (Qx * Qz - Qy * Qw)) + V.Y * (2 * (Qy * Qz + Qx * Qw)) + V.Z * (1 - 2 * (Qx^2 + Qy^2))

矩阵4X4 创建旋转矩阵(四元数 四元旋转)
{
    矩阵4X4 旋转矩阵;
    float num = 四元旋转.X * 四元旋转.X;
    float num2 = 四元旋转.Y * 四元旋转.Y;
    float num3 = 四元旋转.Z * 四元旋转.Z;
    float num4 = 四元旋转.X * 四元旋转.Y;
    float num5 = 四元旋转.Z * 四元旋转.W;
    float num6 = 四元旋转.Z * 四元旋转.X;
    float num7 = 四元旋转.Y * 四元旋转.W;
    float num8 = 四元旋转.Y * 四元旋转.Z;
    float num9 = 四元旋转.X * 四元旋转.W;
    旋转矩阵 = 矩阵4X4::单位矩阵();
    旋转矩阵.M11 = 1.0f - 2.0f * (num2 + num3);
    旋转矩阵.M12 = 2.0f * (num4 + num5);
    旋转矩阵.M13 = 2.0f * (num6 - num7);
    旋转矩阵.M21 = 2.0f * (num4 - num5);
    旋转矩阵.M22 = 1.0f - 2.0f * (num3 + num);
    旋转矩阵.M23 = 2.0f * (num8 + num9);
    旋转矩阵.M31 = 2.0f * (num6 + num7);
    旋转矩阵.M32 = 2.0f * (num8 - num9);
    旋转矩阵.M33 = 1.0f - 2.0f * (num2 + num);
    return 旋转矩阵;
}

矩阵4X4 创建旋转矩阵(float x, float y, float z)
{
    四元数 四元旋转 = 四元数::创建欧拉角旋转(向量三维(x, y, z));
    return 创建旋转矩阵(四元旋转);
}

矩阵4X4 创建变换矩阵(float 缩放, 四元数 旋转, 向量三维 平移)
{
    矩阵4X4 矩阵, m1, m2, m3;
    m1 = 矩阵4X4::创建缩放矩阵(缩放);
    m2 = 创建旋转矩阵(旋转);
    m3 = 矩阵4X4::创建平移矩阵(平移);
    矩阵 = m1 * m2 * m3;
    return 矩阵;
}

矩阵4X4 创建仿射变换矩阵(float 缩放, 向量三维 旋转中心, 四元数 旋转, 向量三维 平移)
{
    矩阵4X4 result, m1, m2, m3, m4, m5;
    m1 = 矩阵4X4::创建缩放矩阵(缩放);
    m2 = 矩阵4X4::创建平移矩阵(-旋转中心);
    m3 = 创建旋转矩阵(旋转);
    m4 = 矩阵4X4::创建平移矩阵(旋转中心);
    m5 = 矩阵4X4::创建平移矩阵(平移);
    result = m1 * m2 * m3 * m4 * m5;
    return result;
}

矩阵4X4 创建仿射变换矩阵(向量三维 缩放中心, 四元数 缩放旋转, 向量三维 缩放, 向量三维 旋转中心, 四元数 旋转, 向量三维 平移)
{
    矩阵4X4 矩阵, m1, m2, m3, m4, m5, m6, m7, m8;
    矩阵4X4 matrix = 创建旋转矩阵(缩放旋转);
    m1 = 矩阵4X4::创建平移矩阵(-缩放中心);
    m2 = 矩阵4X4::计算转置矩阵(matrix);
    m3 = 矩阵4X4::创建缩放矩阵(缩放);
    m4 = 矩阵4X4::创建平移矩阵(缩放中心);
    m5 = 矩阵4X4::创建平移矩阵(-旋转中心);
    m6 = 创建旋转矩阵(旋转);
    m7 = 矩阵4X4::创建平移矩阵(旋转中心);
    m8 = 矩阵4X4::创建平移矩阵(平移);
    矩阵 = m1 * m2 * m3 * matrix * m4 * m5 * m6 * m7 * m8;
    return 矩阵;
}
