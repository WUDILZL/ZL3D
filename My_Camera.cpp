#include "My_Camera.h"

My_Camera::My_Camera()
{
	队列索引 = 0;


	焦距 = 50.0f;
	视锥角度 = 54.0f;
	游标距离 = 10.0f;
	_焦距 = 50.0f;
	_视锥角度 = 54.0f;
	_游标距离 = 10.0f;
	游标坐标 = 向量三维(0, 0, 0);
	坐标 = 向量三维(0, 0.0f, -10.0f);
	名称 = QString::fromLocal8Bit("透视相机");
	设置变换_坐标(坐标);
	//更新矩阵();

	事件_更新投影矩阵();
}


My_Camera::~My_Camera()
{
}

void My_Camera::事件_更新投影矩阵()
{
	
	投影矩阵 = 矩阵4X4::创建视野透视投影矩阵(计算::角度转弧度(视锥角度), 宽高比, 近端修剪, 远端修剪);
}

void My_Camera::通知投影矩阵改变()
{
	事件_更新投影矩阵();
}

void My_Camera::设置变量_焦距(float value)
{
	_焦距 = value;
	_视锥角度 = 焦距转视野角度(_焦距, 54);
	事件_更新投影矩阵();
}

void My_Camera::设置变量_视锥角度(float value)
{
	_视锥角度 = value;
	_焦距 = 视野角度转焦距(_视锥角度, 54);
	事件_更新投影矩阵();
}

void My_Camera::设置变量_游标距离(float value)
{
	_游标距离 = value;
}

float My_Camera::焦距转视野角度(float 焦距数据, float 传感器尺寸)
{
	return 2 * std::atan(传感器尺寸 / (2 * 焦距数据)) * (180 / 计算PI);
}

float My_Camera::视野角度转焦距(float 视野角度数据, float 传感器尺寸)
{
	float fovInRadians = 视野角度数据 * (计算PI / 180); // 将视野角度转换为弧度
	return 传感器尺寸 / (2 * std::tan(fovInRadians / 2));
}

void My_Camera::获取鼠标数据(float 滚动值, float x, float y)
{
	
	float 鼠标移动 = 滚动值 * 向量三维::计算距离(游标坐标, 世界坐标) * 0.001f;
	设置惯性平移(向量三维(0, 0, 鼠标移动));

	float 鼠标移动x = x * 0.001f;
	float 鼠标移动y = y * -0.001f;
	四元旋转 = 四元数::创建轴角旋转(四元旋转 * 向量三维::X轴(), 鼠标移动y) * 四元旋转;
	设置变换_四元旋转(四元旋转);
	四元旋转 = 四元数::创建轴角旋转(-向量三维::Y轴(), 鼠标移动x) * 四元旋转;
	设置变换_四元旋转(四元旋转);

	向量三维 临时坐标 = 坐标 - 游标坐标;
	四元数 临时旋转 = 四元数::创建轴角旋转(四元旋转 * 向量三维::X轴(), 鼠标移动y) * 四元数::创建轴角旋转(-向量三维::Y轴(), 鼠标移动x);
	临时坐标 = 临时旋转 * 临时坐标;
	坐标 = 临时坐标 + 游标坐标;
	设置变换_坐标(坐标);
	
}

/*
* 
 观察相机 需要三个相互垂直（或非线性）的轴定义的一个坐标空间
     glm::vec3 视角指向相机单位方向向量 = glm::vec3(1.0f);
	//物体指向相机z
	视角指向相机单位方向向量 = glm::normalize(相机坐标 - 目标坐标);
	glm::vec3 上向量 = glm::vec3(0.0f, 1.0f, 0.0f);
	//用 视角的z方向向量 和 y上向量 叉乘得出x的方向向量
	glm::vec3 右向量 = glm::vec3(0.0f, 1.0f, 0.0f);
	//x 轴方向向量
	右向量 = glm::normalize(glm::cross(上向量, 视角指向相机单位方向向量));
	//y轴方向向量
	glm::vec3 y向量 = glm::cross(视角指向相机单位方向向量, 右向量);

*/


